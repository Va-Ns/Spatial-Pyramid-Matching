%% Clean-up
clear;clc;close('all');
%%
delete(gcp('nocreate'))
maxWorkers = maxNumCompThreads;
disp("Maximum number of workers: " + maxWorkers);
pool=parpool(maxWorkers/2);

%% Get images directory and form the imageDatastore
fileLocation = uigetdir();
datastore = imageDatastore(fileLocation,"IncludeSubfolders",true, ...
    "LabelSource","foldernames");

%% Counting the number of labels 
initialLabels = countEachLabel(datastore);

if diff(initialLabels{:,2})~=0
    msg = 'The data do not have equal number of labels';
    uiwait(msgbox(msg,'Message'))
end

% If you want to also return the tables of the label count of the training
% and testing datastores, use flag


%% Splitting the datastore
splitDatastore = splitEachLabel(datastore,1/4);
newlabels = countEachLabel(splitDatastore);

[Trainds,Testds] = splitTheDatastore(splitDatastore,newlabels);

% if flag = true, follow the syntax bellow:
% [Trainds,Testds,training_labels,testing_labels] = ...
% splitTheDatastore(datastore,initialLabels,flag,true);

tic
%% Generate SIFT descriptors using Dense SIFT.
train_features = denseSIFTVasilakis(Trainds);
test_features = denseSIFTVasilakis(Testds);

%% Formating the Dictionary and extracting the SIFT matrices for the sets
for k = 1: length(train_features)
        reset(train_features{k})
end
Dictionary = DictionaryFormationVasilakis(train_features);

%% Histogram Representation of Images
% Dictionary = gather(Dictionary);
for i = 1 :length(train_features)
    reset(train_features{i});
end 

for i = 1 :length(test_features)
    reset(test_features{i});
end 

training_vector_images = cell(length(train_features),1);
for i = 1:length(train_features)

    feature = read(train_features{i});
    [~,index] = pdist2(gather(Dictionary),feature.data,'euclidean','Smallest',1);
    training_vector_images{i} = index';
    
end

testing_vector_images = cell(length(test_features),1);

for i = 1:length(test_features)

    feature = read(test_features{i});    
    [~,index] = pdist2(Dictionary,feature.data,'euclidean','Smallest',1);
    testing_vector_images{i} = index';

end

%% Compiling,formulating the Spatial Pyramid and Building the Histogram Intersection of images
for i = 1 :length(train_features)
    reset(train_features{i});
end 

for i = 1 :length(test_features)
    reset(test_features{i});
end 



Training_Pyramid_Vectors = SpatialPyramidVasilakis(training_vector_images, ...
    train_features,Dictionary,"Levels",2);

nz_Train = nnz(Training_Pyramid_Vectors);

Testing_Pyramid_Vectors = SpatialPyramidVasilakis(testing_vector_images, ...
    test_features,Dictionary,"Levels",2);


% Check for use of Sparse Matrix
nz_Test = nnz(Testing_Pyramid_Vectors);

if nz_Train <= (size(Training_Pyramid_Vectors,1)* ...
        size(Training_Pyramid_Vectors,2))/3 && nz_Test <=... 
        ( size(Testing_Pyramid_Vectors,1)* ...
        size(Testing_Pyramid_Vectors,2) )/3

    disp('Using Sparse Matrix')

    S_Train = spalloc(size(Training_Pyramid_Vectors,1), ...
                      size(Training_Pyramid_Vectors,2),nz_Train);

    S_Test = spalloc(size(Training_Pyramid_Vectors,1), ...
                      size(Training_Pyramid_Vectors,2),nz_Test);
    
    S_Train = sparse(Training_Pyramid_Vectors);
    S_Test = sparse(Testing_Pyramid_Vectors);
    
    clear Training_Pyramid_Vectors Testing_Pyramid_Vectors
    % In case you need to find the indices of the data
    % [row,col,val] = find(S_Train);

    % Building the histogram intersection of images
    S_K_train = hist_intersection_Vasilakis(S_Train,S_Train);
    S_K_test = hist_intersection_Vasilakis(S_Test,S_Train);

else
    
    % Building the histogram intersection of images

    K_train = hist_intersection_Vasilakis(Training_Pyramid_Vectors, ...
                                          Training_Pyramid_Vectors);
    K_test = hist_intersection_Vasilakis(Testing_Pyramid_Vectors, ...
                                         Training_Pyramid_Vectors);

end

%% Training a Classifier 

if exist("S_K_train","var")
    t = templateSVM('SaveSupportVectors',true,'Standardize',true,'Type', ...
                    'classification');
    [Model1,HyperparameterOptimizationResults] = fitcecoc(S_K_train, ...
        Trainds.Labels,"Learners",t,"Coding", "onevsall", ...
        'OptimizeHyperparameters',{'BoxConstraint','KernelScale'}, ...
        'HyperparameterOptimizationOptions',struct('KFold',10,'UseParallel', ...
         true));

    [predictedLabels_fitcecoc, scores_fitcecoc]= predict(Model1,S_K_test);
    confusionMatrix_fitcecoc = confusionmat(Testds.Labels, ...
                                        predictedLabels_fitcecoc);
    fitcecoc_Accuracy = (sum(diag(confusionMatrix_fitcecoc))/ ...
                         sum(confusionMatrix_fitcecoc(:)))*100


    classifier = fitcauto(gpuArray(S_K_train),Trainds.Labels, ...
    'OptimizeHyperparameters','auto','HyperparameterOptimizationOptions', ...
     struct('KFold',10)); 

    % Perform predictions 
    [predictedLabels, scores]= predict(classifier,S_K_test);

    % Validate the performance of the model 

    confusionMatrix = confusionmat(Testds.Labels,predictedLabels);
    Accuracy = ( sum(diag(confusionMatrix)) / sum(confusionMatrix(:)) )*100

elseif exist("K_train","var")

    t = templateSVM('SaveSupportVectors',true,'Standardize',true,'Type', ...
                    'classification');
    [Model1,HyperparameterOptimizationResults] = fitcecoc(K_train, ...
        Trainds.Labels,"Learners",t,"Coding", "onevsall", ...
        'OptimizeHyperparameters',{'BoxConstraint','KernelScale'}, ...
        'HyperparameterOptimizationOptions',struct('KFold',10,'UseParallel', ...
         true));

    [predictedLabels_fitcecoc, scores_fitcecoc]= predict(Model1,K_test);
    confusionMatrix_fitcecoc = confusionmat(Testds.Labels, ...
                                        predictedLabels_fitcecoc);
    
    fitcecoc_Accuracy = (sum(diag(confusionMatrix_fitcecoc))/ ...
                         sum(confusionMatrix_fitcecoc(:)))*100


    classifier = fitcauto(gpuArray(K_train),Trainds.Labels, ...
    'OptimizeHyperparameters','auto','HyperparameterOptimizationOptions', ...
     struct('KFold',10)); 

    % Perform predictions 
    [predictedLabels, scores]= predict(classifier,S_K_test);

    % Validate the performance of the model 

    confusionMatrix = confusionmat(Testds.Labels,predictedLabels);
    Accuracy = ( sum(diag(confusionMatrix)) / sum(confusionMatrix(:)) )*100

end


Algorithms_time = toc;