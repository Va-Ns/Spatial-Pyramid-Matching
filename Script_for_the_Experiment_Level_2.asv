delete(gcp('nocreate'))
maxWorkers = maxNumCompThreads;
disp("Maximum number of workers: " + maxWorkers);
pool=parpool(maxWorkers);

tic
for o = 1:10

    %% Get images directory and form the imageDatastore
    fileLocation =['C:\Users\Nik_Vas\Documents\GitHub\Spatial-Pyramid-Matching' ...
        '\scene_categories'];
    datastore = imageDatastore(fileLocation,"IncludeSubfolders",true, ...
        "LabelSource","foldernames");

    initialLabels = countEachLabel(datastore);

    splitDatastore = splitEachLabel(datastore,1/4);
    newlabels = countEachLabel(splitDatastore);

    [Trainds,Testds] = splitTheDatastore2(splitDatastore,newlabels);

    
    %% Generate SIFT descriptors using Dense SIFT.
    train_features = denseSIFTVasilakis(Trainds,"Grid_Spacing",8);
    test_features = denseSIFTVasilakis(Testds,"Grid_Spacing",8);

    %% Formating the Dictionary and extracting the SIFT matrices for the sets
    for k = 1: length(train_features)
        reset(train_features{k})
    end
    Dictionary = DictionaryFormationVasilakis(train_features);

    %% Histogram Representation of Images
    % Dictionary = gather(Dictionary);
    for i = 1 :length(train_features)
        reset(train_features{i});
    end

    for i = 1 :length(test_features)
        reset(test_features{i});
    end

    training_vector_images = cell(length(train_features),1);
    for i = 1:length(train_features)

        feature = read(train_features{i});
        [~,index] = pdist2(gather(Dictionary),feature.data,'euclidean','Smallest',1);
        training_vector_images{i} = index';

    end

    testing_vector_images = cell(length(test_features),1);

    for i = 1:length(test_features)

        feature = read(test_features{i});
        [~,index] = pdist2(Dictionary,feature.data,'euclidean','Smallest',1);
        testing_vector_images{i} = index';

    end

    %% Compiling,formulating the Spatial Pyramid and Building the Histogram Intersection of images
    for i = 1 :length(train_features)
        reset(train_features{i});
    end

    for i = 1 :length(test_features)
        reset(test_features{i});
    end

    Training_Pyramid_Vectors = SpatialPyramidVasilakis(training_vector_images, ...
        train_features,Dictionary,"Levels",2);

    nz_Train = nnz(Training_Pyramid_Vectors);

    Testing_Pyramid_Vectors = SpatialPyramidVasilakis(testing_vector_images, ...
        test_features,Dictionary,"Levels",2);


    % Check for use of Sparse Matrix
    nz_Test = nnz(Testing_Pyramid_Vectors);

    if nz_Train <= (size(Training_Pyramid_Vectors,1)* ...
            size(Training_Pyramid_Vectors,2))/3 && nz_Test <=...
            (size(Testing_Pyramid_Vectors,1)* ...
            size(Testing_Pyramid_Vectors,2))/3

        disp('Using Sparse Matrix')

        S_Train = spalloc(size(Training_Pyramid_Vectors,1), ...
            size(Training_Pyramid_Vectors,2),nz_Train);

        S_Test = spalloc(size(Training_Pyramid_Vectors,1), ...
            size(Training_Pyramid_Vectors,2),nz_Test);

        S_Train = sparse(Training_Pyramid_Vectors);
        S_Test = sparse(Testing_Pyramid_Vectors);

        clear Training_Pyramid_Vectors Testing_Pyramid_Vectors
        % In case you need to find the indices of the data
        % [row,col,val] = find(S_Train);

        % Building the histogram intersection of images
        S_K_train = hist_intersection_Vasilakis(S_Train,S_Train);
        S_K_test = hist_intersection_Vasilakis(S_Test,S_Train);

    else

        % Building the histogram intersection of images

        K_train = hist_intersection_Vasilakis(Training_Pyramid_Vectors, ...
            Training_Pyramid_Vectors);
        K_test = hist_intersection_Vasilakis(Testing_Pyramid_Vectors, ...
            Training_Pyramid_Vectors);

    end

    %% Training a Classifier

    if exist("S_K_train","var")

        t = templateSVM('SaveSupportVectors',true,'Standardize',true,'Type', ...
            'classification');
        Models(o).Model = fitcecoc(S_K_train, Trainds.Labels,"Learners",t, ...
            "Coding", "onevsall",'OptimizeHyperparameters', ...
            {'BoxConstraint','KernelScale'}, ...
            'HyperparameterOptimizationOptions',struct('KFold',10, ...
            'UseParallel',true,'Optimizer','bayesopt','ShowPlots',false, ...
            'Verbose',0,'Repartition',true));

        HyperparameterOptimizationResults = Models(o).Model.HyperparameterOptimizationResults.XAtMinEstimatedObjective;

        [predictedLabels, scores]= predict(Models(o).Model,S_K_test);
        confusionMatrix_fitcecoc = confusionmat(Testds.Labels, ...
            predictedLabels);

        Accuracy(o) = (sum(diag(confusionMatrix_fitcecoc))/ ...
            sum(confusionMatrix_fitcecoc(:)))*100;

    elseif exist("K_train","var")

        t = templateSVM('SaveSupportVectors',true,'Standardize',true,'Type', ...
            'classification');
        Models(o).Model = fitcecoc(K_train,Trainds.Labels,"Learners",t, ...
            "Coding", "onevsall",'OptimizeHyperparameters', ...
            {'BoxConstraint','KernelScale'}, ...
            'HyperparameterOptimizationOptions',struct('KFold',10, ...
            'UseParallel',true,'Optimizer','bayesopt','ShowPlots',false, ...
            'Verbose',0,'Repartition',true));

        HyperparameterOptimizationResults(o) = Models(o).Model.HyperparameterOptimizationResults.XAtMinEstimatedObjective;

        [predictedLabels, scores]= predict(Models(o).Model,K_test);
        confusionMatrix_fitcecoc = confusionmat(Testds.Labels, ...
            predictedLabels);

        Accuracy(o) = (sum(diag(confusionMatrix_fitcecoc))/ ...
            sum(confusionMatrix_fitcecoc(:)))*100;
    end

    clearvars -except HyperparameterOptimizationResults Accuracy Models
end
Algorithms_time = toc;
Mean_Accuracy = mean(Accuracy);