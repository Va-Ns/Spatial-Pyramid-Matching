function sift_arr = sp_normalize_sift(sift_arr)
% normalize SIFT descriptors (after Lowe)

% find indices of descriptors to be normalized (those whose norm is larger 
% than 1)

% Στο σημείο αυτό εντοπίζουμε ποιοί από τους περιγραφείς θα πρέπει να
% κανονικοποιηθούν. Ως κριτήριο για το τελευταίο, θέτουμε ότι θέλουμε η
% νόρμα τους να είναι μεγαλύτερη από το 1.

% Μεγάλη προσοχη! Ο υπολογισμός της νόρμας γίνεται σε κάθε σειρά του πίνακα
% sift_arr γιατί η κάθε σειρά αντικατοπτρίζει κι ένα ξεχωριστό keypoint
% στην εικόνα.
tmp = sqrt(sum(sift_arr.^2, 2));

% Βρίσκουμε τους δείκτες αυτούς που ανταποκρίνονται στο κριτήριό μας.
normalize_ind = find(tmp > 1);

% Επιλέγουμε τα δεδομένα του SIFT βάσει των δεικτών που ανταποκρίνονται στο
% κριτήριο που θέσαμε παραπάνω και τους τοποθετούμε σε μια καινούργια
% μεταβλητή.
sift_arr_norm = sift_arr(normalize_ind,:);

% Πραγματοποιούμε διαίρεση στοιχείο-προς-στοιχείο (element-wise) ώστε να
% μπορέσουμε να κανονικοποιήσουμε τους περιγραφείς SIFT 
sift_arr_norm = sift_arr_norm ./ repmat(tmp(normalize_ind,:),[1 size(sift_arr,2)]);          
%                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
%                                Εδώ επαναλαμβάνουμε τον πίνακα της νόρμας
%                                με όλες εκείνες τις τιμές που βρήκαμε ότι
%                                είναι μεγαλύτερες του 1, τόσες φορές όσες
%                                είναι η δεύτερη διάσταση της μεταβλητής
%                                sift_arr.

% suppress large gradients

% Υποθάλπτουμε μεγάλες κλίσεις. Ο λόγος για τον οποίο το κάνουμε αυτό είναι
% για να μειώσουμε την επιρροή χαρακτηριστικών με μεγάλη αντίθεση στην 
% εικόνα, όπως για παράδειγμα οι ακμές. Αυτό γίνεται διότι χαρακτηριστικά
% με υψηλές τιμές αντίθεσης μπορούν να κυριαρχήσουν στον εκάστοτε
% περιγραφέα και να τον κάνουν ευαίσθητο σε αλλαγές φωτισμού ή θορύβου.
sift_arr_norm(find(sift_arr_norm > 0.2)) = 0.2;

% finally, renormalize to unit length

% Εδώ θα χρειαστεί να ξανακανονικοποιήσουμε, διότι έχει προηγηθεί η
% διαδικασία της εξασθένισης μεγάλων κλίσεων. Άρα εφόσον άλλαξαν οι τιμές
% του πίνακα θα πρέπει να γίνει ξανά κανονικοποίηση.
tmp = sqrt(sum(sift_arr_norm.^2, 2));
sift_arr_norm = sift_arr_norm ./ repmat(tmp, [1 size(sift_arr,2)]);

% Η σύνταξη αυτή χρησιμοποιείται για να τοποθετηθούν μόνο όσοι δείκτες
% χρειάζεται να κανονικοποιηθούν πίσω στην sift_arr. Για το λόγο αυτό
% μπορούμε να ελέγξουμε κι όλας ότι η μεταβλητή sift_arr_norm και η
% μεταβλητή normalize_ind έχουν το ίδιο μέγεθος στην πρώτη διάσταση.
sift_arr(normalize_ind,:) = sift_arr_norm;
